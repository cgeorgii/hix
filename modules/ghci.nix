{
  lib,
  config,
  ...
}:
with builtins;
with lib;
let

  pkgs = config.internal.basicPkgs;

  newerThan810 = match "ghc(81|9).*" config.devGhc.compiler != null;

  libDir = pkg:
  "$PWD/" + (if pkg == "." then "lib" else "${pkg}/lib");

  srcDir = pkg:
  "$PWD/" + (if pkg == "." then "src" else "${pkg}/src");

  colonSeparated =
    concatStringsSep ":";

  searchPaths = paths:
    "-i${colonSeparated paths}";

  inherit (config.ghci) options_ghc;

  preludeScript =
    ''
      :load Prelude
      import Prelude
      :set -XImplicitPrelude
    '';

  cwdScript = cwd:
  optionalString (cwd != null) ''
    :cd ${cwd}
  '';

  builtinTestScripts = {
    hedgehog-property = module: ''
      :load ${module}
      import ${module}
      import Hedgehog (check)
    '';

    hedgehog-unit = module: ''
      :load ${module}
      import ${module}
      import Hedgehog (check, property, test, withTests)
    '';

    tasty-tree = module: ''
      :load ${module}
      import ${module}
      import Test.Tasty (defaultMain)
    '';

    generic = module: ''
      :load ${module}
      import ${module}
    '';
  };

  builtinTestRunners = {
    hedgehog-property = name: "check ${name}";
    hedgehog-unit = name: "(check . withTests 1 . property . test) ${name}";
    tasty-tree = name: "defaultMain ${name}";
    generic = id;
  };

  preludeFix = config.ghci.preludePackage != null || config.ghci.preludeModule != null;

  preludeSearchCode = pkg: module: ''
  module Prelude (module ${module}) where
  import ${pkg} ${module}
  '';

  preludeSearchFile =
    let
      module =
        if config.ghci.preludeModule == null
        then "Prelude"
        else config.ghci.preludeModule;
    in
      if config.ghci.preludePackage == null
      then preludeSearchCode "" module
      else preludeSearchCode ''"${config.ghci.preludePackage}"'' module;

  preludeSearch =
    let
      preludeDir = pkgs.writeTextFile {
        name = "prelude-reexport";
        text = preludeSearchFile;
        destination = "/Prelude.hs";
      };
    in
      "${preludeDir}";

  ghciScript = cwd: script:
  let
    scriptText = if isAttrs script then script.script else script;
  in
  cwdScript cwd +
  # optionalString preludeFix preludeScript +
  scriptText;

  command = {
    packages,
    script,
    search,
    cwd ? null,
  }:
  let
    searchP =
      searchPaths (
        map srcDir (attrValues packages) ++
        map libDir (attrValues packages) ++
        search
        # ++
        # optional preludeFix preludeSearch
      );
    script' = ghciScript cwd script;
    scriptFile = pkgs.writeText "ghci-script" script';
  in {
    inherit searchP scriptFile;
    script = script';
    cmdline = "ghci ${toString config.ghci.args} ${searchP} -ghci-script ${scriptFile}";
  };

in {

  options.ghci = with types; {

    args = mkOption {
      type = listOf str;
      description = mdDoc ''
        The command line arguments passed to GHCi.
        Setting this option appends to the defaults, so in order to replace them, use `mkForce`.
        To only override basic GHC options like `-Werror`, use `ghci.ghcOptions`.
      '';
    };

    ghcOptions = mkOption {
      type = listOf str;
      description = mdDoc ''
        Command line arguments passed to GHCi that aren't related to more complex Hix config like Prelude overrides and
        the extensions preprocessor.
        This option is initialized with values that use the Nix setting `cores` to set the number of
        threads GHCi should use. If you want to control this yourself, use `mkForce` here.
      '';
      default = [];
    };

    scripts = mkOption {
      description = mdDoc ''
        A set of Cabal scripts, to be referenced by entries in `ghcid.commands`.
      '';
      type = attrsOf (functionTo lines);
      example = literalExpression ''
      {
        :set args --port 8080
        :load Main
        import Main
      }
    '';
    };

    runners = mkOption {
      description = mdDoc ''
        A function returning Haskell code that should be executed by GHCi when running a test.
        The argument is the test function name, as passed in via command line arguments.
      '';
      type = attrsOf (functionTo str);
    };

    options_ghc = mkOption {
      description = mdDoc "Global GHC options inserted into each file processed by GHCi.";
      type = str;
      default = "";
    };

    extensions = mkOption {
      description = mdDoc ''
        Global GHC extensions inserted into each file processed by GHCi.
        Since `ghcid` cannot read Cabal files, these have to be set manually.
      '';
      type = nullOr (listOf str);
      default = null;
    };

    preprocessor = mkOption {
      description = mdDoc ''
        The preprocessor script used to insert extensions, custom Prelude and
        `ghci.extensions` into source files.
        This is generated by Hix, but may be overridden.
      '';
      type = path;
    };

    preprocessorExtraCode = mkOption {
      description = mdDoc ''
        Extra Haskell code to be inserted into source files by the preprocessor.
      '';
      type = lines;
      default = "";
    };

    command = mkOption {
      description = mdDoc "Internal API function for creating GHCi commands.";
      type = functionTo unspecified;
    };

  };

  config.ghci = {
    ghcOptions = ["-j$NIX_BUILD_CORES" "+RTS -A64M -RTS" "-XHaskell2010"];

    preprocessor = mkDefault (import ../lib/preprocessor.nix {
      inherit pkgs;
      cli = "${config.internal.hixCli.package}/bin/hix";
      extraCode = config.ghci.preprocessorExtraCode;
      inherit (config.ghci) options_ghc;
    });

    args =
      config.ghci.ghcOptions
      ++
      ["-F" "-pgmF" (toString config.ghci.preprocessor)]
      ;

    scripts = builtinTestScripts;

    runners = builtinTestRunners;

    command = mkDefault command;
  };
}
